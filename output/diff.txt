// src/backend/services/company/company.service.ts
```ts
	import DateUTC from '@/utils/datetime/date.custom';
	import mongoose, { Mongoose, SortOrder } from 'mongoose';
	import CompanyDto, { Company } from '@/utils/dtos/company.dto';
	import CompanyRepositoryInterface from '@/backend/repositories/interfaces/company.repository.interface';
	import CompanyRepository from '@/backend/repositories/mongodb/company.repository';
	import { generateKeyFromName, parsePayloadCompanyToCreateData } from '@/utils/helper';
	import NotFoundException from '@/backend/exceptions/notfound.exception';
	import { MemberInviteSource, MemberInviteStatus, Roles } from '@/utils/enums';
	import { IMemberCompany } from '@/types/resource/company';
	import RoleService from '@/backend/services/role.service';
	import PaginationStruct from '@/backend/structs/pagination.struct';
	import UserRepository from '@/backend/repositories/mongodb/user.repository';
	import MongoConnect from '@/backend/connection/mongo.connection';
	import StorageFactory from '@/backend/services/storage/storage.factory';
	import { FolderName } from '@/utils/enums';
	import UserDto from '@/utils/dtos/user.dto';
	import RoleRepository from '@/backend/repositories/mongodb/role.repository';
	import DuplicateException from '@/backend/exceptions/duplicate.exception';
	
	export default class CompanyService {
	  protected companyRepository: CompanyRepositoryInterface;
	  protected roleService: RoleService;
	  protected storageFactory: StorageFactory;
	
	  constructor(conn: Mongoose) {
	    this.companyRepository = new CompanyRepository(conn);
	    this.roleService = new RoleService(conn);
	    this.storageFactory = new StorageFactory();
	  }
	
	  /** Find a company by id */
	  async getCompany(id: string) {
	    return await this.companyRepository.findOne({ _id: id });
	  }
	
	  /** Create a builder */
	  async createCompany(formData: FormData, currentUser: UserDto): Promise<mongoose.Document> {
	    const data = parsePayloadCompanyToCreateData(formData);
	    const companyDto = new CompanyDto();
	    const defaultData = companyDto.toObject();
	    let imageUrl = companyDto.imageUrl;
	    let newImageUrl = null;
	    if (data.image) {
	      imageUrl = await this.storageFactory.getStorage().uploadFile(data.image, FolderName.COMPANY);
	      newImageUrl = imageUrl;
	    }
	
	    // create position auto increment
	    const lastCompany: mongoose.Document<Company>[] = await this.companyRepository.findWithSort({}, { position: 'desc' }, 1);
	    let lastIndex = 1;
	    if (!!lastCompany && lastCompany.length > 0) {
	      const lastItem: Company = lastCompany[0].toObject();
	      lastIndex = Number(lastItem.position) + 1;
	    }
	
	    companyDto.setData({
	      ...defaultData,
	      name: data.name,
	      key: generateKeyFromName(data.name),
	      service: data.service,
	      type: data.type,
	      address: data.address || '',
	      createdBy: currentUser.toObject().id,
	      imageUrl: imageUrl,
	      position: lastIndex
	    });
	
	    try {
	      return await this.companyRepository.create(companyDto);
	    } catch (error: any) {
	      if (!!newImageUrl) {
	        await this.storageFactory.getStorage().removeFile(newImageUrl);
	      }
	
	      if (error.code === 11000) {
	        throw new DuplicateException('Company name already exists');
	      }
	
	      throw error;
	    }
	  }
	
	  /** Get company by type and name */
	  async findCompaniesByTypeAndName(
	    name: string,
	    companyType: string
	  ): Promise<{
	    data: Company[];
	  }> {
	    const companyDto = new CompanyDto();
	
	    const filterSearch = { type: companyType, name };
	    const companies = await this.companyRepository.find(filterSearch);
	    const data: Company[] = [];
	    companies.forEach((budget: mongoose.Document<Company>) => {
	      companyDto.setData(budget.toJSON());
	      const currentObject = companyDto.toObject() as Company;
	      data.push(currentObject);
	    });
	    return {
	      data
	    };
	  }
	
	  /** Add a user to company */
	  async addUserToCompany(companyId: string, data: Partial<IMemberCompany>): Promise<mongoose.Document | null> {
	    try {
	      const company = await this.getCompany(companyId || '');
	      if (!company) {
	        throw new NotFoundException('Company not found');
	      }
	      const companyDto = new CompanyDto();
	      const currentCompanyObj: Company = company.toObject();
	      const currentMember = currentCompanyObj.members;
	      const userId = data?.userId || '';
	      const existUserOnMember = currentMember.some((c) => c.userId === userId);
	      if (existUserOnMember) {
	        throw new Error('User already exists in company');
	      }
	      let currentRole = data?.roleId || '';
	      if (!currentRole) {
	        const roleGeneric = await this.roleService.getRoleByFields({ name: Roles.SYSTEM_GENERIC });
	        if (roleGeneric) {
	          currentRole = roleGeneric.id;
	        }
	      }
	
	      currentMember.push({
	        roleId: currentRole,
	        userId,
	        inviteCreatedAt: new DateUTC(),
	        inviteSource: data?.inviteSource || MemberInviteSource.SELF_SIGNUP,
	        inviteStatus: data?.inviteStatus || MemberInviteStatus.PENDING_SIGNUP,
	        inviteKey: data?.inviteKey || null,
	        inviteExpiration: data?.inviteExpiration || null,
	        inviteUpdatedAt: null
	      });
	      companyDto.setData({
	        ...currentCompanyObj,
	        members: currentMember,
	        dateModify: new DateUTC()
	      });
	      return this.companyRepository.update(companyId, companyDto);
	    } catch (error) {
	      throw error;
	    }
	  }
	  /** Update data of a member on company */
	  async updateFieldsUserCompany(companyId: string, data: Partial<IMemberCompany>): Promise<mongoose.Document | null> {
	    try {
	      const company = await this.getCompany(companyId || '');
	      if (!company) {
	        throw new NotFoundException('Company not found');
	      }
	      const companyDto = new CompanyDto();
	      const currentCompanyObj: Company = company.toObject();
	      const currentListMember = currentCompanyObj.members;
	      const userId = data?.userId || '';
	      const currentIndexMember = currentListMember.findIndex((c) => c.userId === userId);
	      if (currentIndexMember < 0) {
	        throw new NotFoundException('User not found');
	      }
	      const currentMember = currentListMember[currentIndexMember];
	      const newListMember = [
	        ...currentListMember.slice(0, currentIndexMember),
	        {
	          ...currentMember,
	          ...data,
	          inviteSource: data?.inviteSource || currentMember?.inviteSource || MemberInviteSource.SELF_SIGNUP,
	          inviteStatus: data?.inviteStatus || currentMember?.inviteStatus || MemberInviteStatus.PENDING_SIGNUP,
	          inviteKey: data?.inviteKey || currentMember?.inviteKey || null,
	          inviteExpiration: data?.inviteExpiration || currentMember?.inviteExpiration || null,
	          inviteCreatedAt: currentMember.inviteCreatedAt,
	          userId,
	          inviteUpdatedAt: new DateUTC()
	        },
	        ...currentListMember.slice(currentIndexMember + 1)
	      ];
	      companyDto.setData({
	        ...currentCompanyObj,
	        members: newListMember,
	        dateModify: new DateUTC()
	      });
	      return this.companyRepository.update(companyId, companyDto);
	    } catch (error) {
	      throw error;
	    }
	  }
	
	  /**
	   *  Get list companies by pagination
	   *  limit: total items each page (page size)
	   *  offset: current page (default = 0)
	   *  order: Sort the company list by field
	   *  search: Search compamy based on search value and company type
	   * */
	  async listCompany(
	    companyType: string,
	    limit: number,
	    offset: number,
	    order: { [key: string]: SortOrder },
	    search: string
	  ): Promise<{
	    pagination: PaginationStruct;
	    collection: Company[];
	  }> {
	    const conn = await MongoConnect();
	    const companyDto = new CompanyDto();
	    const userRepository = new UserRepository(conn);
	
	    const validOrderFields = Object.keys(companyDto);
	
	    for (const key in order) {
	      if (!validOrderFields.includes(key)) {
	        delete order[key];
	      }
	    }
	
	    if (Object.keys(order).length === 0) {
	      order = { name: 'asc' };
	    }
	
	    let filterSearch = {};
	    if (search !== '') {
	      filterSearch = { name: { $regex: search } };
	    } else if (companyType !== null) {
	      filterSearch = { type: companyType };
	    }
	    const total = await this.companyRepository.count(filterSearch);
	    const companies = await this.companyRepository.findWithSort(filterSearch, order, limit, offset);
	
	    const collection: any[] = [];
	
	    for (const company of companies) {
	      companyDto.setData({
	        ...company.toJSON(),
	        members: [],
	        projectIds: []
	      });
	      const currentObject = companyDto.toObject() as Company;
	
	      // Get user info by currentObject.createdBy
	      const user = await userRepository.findUserId(currentObject.createdBy);
	      // convert user to object
	      const userObj = user.toObject();
	
	      collection.push({
	        ...currentObject,
	        createdBy: userObj,
	      });
	    }
	
	    const pagination = new PaginationStruct(offset, limit, total);
	    return {
	      pagination,
	      collection
	    };
	  }
	
	    /** Check key exist in the company */
	    async checkKeyCompany(key: string): Promise<boolean> {
	      const company = await this.companyRepository.findOne({ key });
	      return !!company; // Convert company to boolean
	    }
	
	    /**
	   *  Get list members of companies by pagination
	   *  limit: total items each page (page size)
	   *  offset: current page (default = 0)
	   *  order: Sort the company list by field
	   * */
	  async listCompanyMembers(
	    companyId: string,
	    limit: number,
	    offset: number,
	    order: { [key: string]: SortOrder }
	  ): Promise<{
	    pagination: PaginationStruct;
	    collection: Company[];
	  }> {
	    const conn = await MongoConnect();
	    const userRepository = new UserRepository(conn);
	    const roleRepository = new RoleRepository(conn);
	
	    // find company by id
	    const company = await this.companyRepository.findOne({ _id: companyId });
	    if (!company) {
	      throw new NotFoundException('Company not found');
	    }
	    // get members of company
	    const members = company.toObject().members;
	    const total = members.length;
	
	
	    const collection: any[] = [];
	
	    for (const member of members) {
	      const user = await userRepository.findUserId(member.userId);
	      const companyRole = await roleRepository.findOne({_id: member.roleId});
	
	      collection.push({
	        id: user._id,
	        firstName: user.firstName,
	        lastName: user.lastName,
	        email: user.email,
	        status: member.inviteStatus,
	        roleName: companyRole? companyRole.toObject().name : ''
	      });
	    }
	
	    let sortBy = 'firstName'; // field to sort by
	    let sortOrder = 'asc'; // sorting order ('asc' or 'desc')
	
	    // check order exists
	    if (order) {
	      const orderKeys = Object.keys(order);
	      if (orderKeys.length > 0) {
	        sortBy = orderKeys[0];
	        sortOrder = order[sortBy].toString(); // Convert sortOrder to string
	      }
	    }
	
	    // Sorting the users array
	    collection.sort((a, b) => {
	      const sortFactor = sortOrder === 'asc' ? 1 : -1;
	      if (a[sortBy] < b[sortBy]) return -1 * sortFactor;
	      if (a[sortBy] > b[sortBy]) return 1 * sortFactor;
	      return 0;
	    });
	
	    // Calculating the start and end index for the current page
	    const startIndex = (offset - 1) * limit;
	    const endIndex = Math.min(startIndex + limit, collection.length);
	
	    // Slicing the users array based on the calculated start and end index
	    const result = collection.slice(startIndex, endIndex);
	
	    const pagination = new PaginationStruct(offset, limit, total);
	    return {
	      pagination,
	      collection: result
	    };
	  }
	}

```