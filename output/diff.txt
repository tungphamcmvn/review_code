title:	J2C-119 API for User Management - Activate/Deactivate Popup
state:	MERGED
author:	MinhT191195
labels:	
assignees:	
reviewers:	
projects:	
milestone:	
number:	8
url:	https://github.com/invik-33/j2c-app/pull/8
additions:	156
deletions:	10
--



diff --git a/lib/swagger/doc/user/bulkControl.ts b/lib/swagger/doc/user/bulkControl.ts
index beff072..46bbf14 100644
--- a/lib/swagger/doc/user/bulkControl.ts
+++ b/lib/swagger/doc/user/bulkControl.ts
@@ -2,8 +2,8 @@
  * @swagger
  * /user/bulk-control:
  *   patch:
- *     summary: Bulk control users
- *     description: Bulk control users
+ *     summary: Bulk control users update status to activate, deactivate, locked or delete by ids
+ *     description: Bulk control users update status to activate, deactivate, locked or delete by ids
  *     tags:
  *       - User
  *     requestBody:
diff --git a/lib/swagger/doc/user/updateStatus.ts b/lib/swagger/doc/user/updateStatus.ts
new file mode 100644
index 0000000..95d256b
--- /dev/null
+++ b/lib/swagger/doc/user/updateStatus.ts
@@ -0,0 +1,75 @@
+/**
+ * @swagger
+ * /user/{id}/status:
+ *   patch:
+ *     summary: Update user status to activate or deactivate
+ *     tags:
+ *       - User
+ *     security:
+ *       - bearerAuth: []
+ *     parameters:
+ *       - in: path
+ *         name: id
+ *         required: true
+ *         description: User ID
+ *     requestBody:
+ *       required: true
+ *       content:
+ *         application/json:
+ *           schema:
+ *             type: object
+ *             properties:
+ *               status:
+ *                 type: string
+ *                 enum: [activate, deactivate]
+ *                 example: activate
+ *                 required: true
+ *     responses:
+ *       200:
+ *         content:
+ *           application/json:
+ *             schema:
+ *               $ref: '#/components/schemas/SuccessResponse'
+ *       400:
+ *         content:
+ *           application/json:
+ *             schema:
+ *               $ref: '#/components/schemas/ErrorResponse'
+ *       404:
+ *         content:
+ *           application/json:
+ *             schema:
+ *               $ref: '#/components/schemas/ErrorResponse'
+ *       500:
+ *         content:
+ *           application/json:
+ *             schema:
+ *               $ref: '#/components/schemas/ErrorResponse'
+ * components:
+ *   schemas:
+ *     SuccessResponse:
+ *       type: object
+ *       properties:
+ *         status:
+ *           type: number
+ *           example: 200
+ *         success:
+ *           type: boolean
+ *           example: true
+ *     ErrorResponse:
+ *       type: object
+ *       properties:
+ *         status:
+ *           type: number
+ *           example: 400
+ *           description: Error status code
+ *         success:
+ *           type: boolean
+ *           example: false
+ *         errors:
+ *           type: array
+ *           items:
+ *             type: string
+ *             example: User id is required.
+ */
+export {};
diff --git a/src/app/api/user/[id]/status/route.ts b/src/app/api/user/[id]/status/route.ts
new file mode 100644
index 0000000..322385b
--- /dev/null
+++ b/src/app/api/user/[id]/status/route.ts
@@ -0,0 +1,70 @@
+import { NextRequest, NextResponse } from 'next/server';
+import MongoConnect from '@/backend/connection/mongo.connection';
+import ResponseStruct from '@/backend/structs/response.struct';
+import UserRepository from '@/backend/repositories/mongodb/user.repository';
+import UserDto from '@/utils/dtos/user.dto';
+import NotFoundException from '@/backend/exceptions/notfound.exception';
+import { headers } from 'next/headers';
+import { decode, JWT } from 'next-auth/jwt';
+import { Actions } from '@/utils/enums';
+import DateCustom from '@/utils/datetime/date.custom';
+
+export async function PATCH(request: NextRequest, { params }: { params: { id: string } }) {
+  const token = headers().get('authorization')?.split(' ')[1];
+  const dataDecode: JWT | null = await decode({
+    token: token as string,
+    secret: (process.env.NEXTAUTH_SECRET as string) || ''
+  });
+
+  const data: { status: Actions } = await request.json();
+  const responseStruct = new ResponseStruct(true);
+
+  if (!params.id) {
+    responseStruct.setStatus(400);
+    responseStruct.pushError('User id is required.');
+
+    return NextResponse.json(responseStruct.getResponse(), { status: 400 });
+  }
+
+  if (dataDecode && dataDecode.id === params.id) {
+    responseStruct.setStatus(400);
+    responseStruct.pushError('You cannot update yourself.');
+
+    return NextResponse.json(responseStruct.getResponse(), { status: 400 });
+  }
+
+  if (data.status !== Actions.ACTIVATE && data.status !== Actions.DEACTIVATE) {
+    responseStruct.setStatus(400);
+    responseStruct.pushError('Allowed status are activate or deactivate.');
+
+    return NextResponse.json(responseStruct.getResponse(), { status: 400 });
+  }
+
+  const conn = await MongoConnect();
+  const userRepository = new UserRepository(conn);
+  try {
+    const user: UserDto = await userRepository.findUserId(params.id);
+
+    if (!user) {
+      throw new NotFoundException('User not found.');
+    }
+
+    await userRepository.update(params.id, {
+      status: data.status,
+      dateModify: new DateCustom(),
+      failedLoginAttempts: data.status === Actions.ACTIVATE ? 0 : user.failedLoginAttempts
+    });
+
+    responseStruct.setStatus(200);
+  } catch (error: any) {
+    responseStruct.setStatus(500);
+
+    if (error instanceof NotFoundException) {
+      responseStruct.setStatus(404);
+    }
+
+    responseStruct.pushError(error.message);
+  }
+
+  return NextResponse.json(responseStruct.getResponse(), { status: responseStruct.getValue('status') });
+}
diff --git a/src/app/api/user/bulk-control/route.ts b/src/app/api/user/bulk-control/route.ts
index 627da69..e00d076 100644
--- a/src/app/api/user/bulk-control/route.ts
+++ b/src/app/api/user/bulk-control/route.ts
@@ -1,5 +1,5 @@
 import { NextRequest, NextResponse } from 'next/server';
-import { BulkAction } from '@/utils/enums';
+import { Actions } from '@/utils/enums';
 import MongoConnect from '@/backend/connection/mongo.connection';
 import UserRepository from '@/backend/repositories/mongodb/user.repository';
 import UserService from '@/backend/services/user.service';
@@ -10,7 +10,7 @@ import { headers } from 'next/headers';
 import { decode, JWT } from 'next-auth/jwt';
 
 export async function PATCH(request: NextRequest) {
-  const data: { ids: string[]; action: BulkAction } = await request.json();
+  const data: { ids: string[]; action: Actions } = await request.json();
   const token = headers().get('authorization')?.split(' ')[1];
   const dataDecode: JWT | null = await decode({
     token: token as string,
diff --git a/src/backend/services/user.service.ts b/src/backend/services/user.service.ts
index df13299..46d3236 100644
--- a/src/backend/services/user.service.ts
+++ b/src/backend/services/user.service.ts
@@ -6,6 +6,7 @@ import PaginationStruct from '@/backend/structs/pagination.struct';
 import { User as UserType } from '@/utils/dtos/user.dto';
 import IdsNotFoundException from '@/backend/exceptions/idsnotfound.exception';
 import NotFoundException from "@/backend/exceptions/notfound.exception";
+import DateCustom from '@/utils/datetime/date.custom';
 
 export default class UserService {
   protected userRepository: UserRepositoryInterface;
@@ -149,13 +150,13 @@ export default class UserService {
         await this.userRepository.deleteMany({ _id: { $in: ids } });
         break;
       case Actions.ACTIVATE:
-        await this.userRepository.updateMany({ _id: { $in: ids } }, { status: UserStatus.ACTIVE });
+        await this.userRepository.updateMany({ _id: { $in: ids } }, { status: UserStatus.ACTIVE, dateModify: new DateCustom() });
         break;
       case Actions.DEACTIVATE:
-        await this.userRepository.updateMany({ _id: { $in: ids } }, { status: UserStatus.INACTIVE });
+        await this.userRepository.updateMany({ _id: { $in: ids } }, { status: UserStatus.INACTIVE, dateModify: new DateCustom() });
         break;
       case Actions.ARCHIVE:
-        await this.userRepository.updateMany({ _id: { $in: ids } }, { status: UserStatus.LOCKED });
+        await this.userRepository.updateMany({ _id: { $in: ids } }, { status: UserStatus.LOCKED, dateModify: new DateCustom() });
         break;
     }
   }
@@ -172,13 +173,13 @@ export default class UserService {
         await this.userRepository.delete(id);
         break;
       case Actions.ACTIVATE:
-        await this.userRepository.update(id, { status: UserStatus.ACTIVE });
+        await this.userRepository.update(id, { status: UserStatus.ACTIVE, dateModify: new DateCustom() });
         break;
       case Actions.DEACTIVATE:
-        await this.userRepository.update(id, { status: UserStatus.INACTIVE });
+        await this.userRepository.update(id, { status: UserStatus.INACTIVE, dateModify: new DateCustom() });
         break;
       case Actions.ARCHIVE:
-        await this.userRepository.update(id, { status: UserStatus.LOCKED });
+        await this.userRepository.update(id, { status: UserStatus.LOCKED, dateModify: new DateCustom() });
         break;
     }
   }
